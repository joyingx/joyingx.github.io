<!DOCTYPE html>
<html lang="">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="description" content="NSMutableArray原理揭露"/>







  <link rel="alternate" href="/atom.xml" title="JoyingX's Blog">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.2.x" />



<link rel="canonical" href="http://blog.joyingx.me/2015/05/03/NSMutableArray 原理揭露/"/>


<meta name="description" content="本文翻译自 Exposing NSMutableArray，译文原地址为NSMutableArray 原理揭露。
以下为译文：
我总好奇 NSMutableArray 内部是如何工作的。别误会，不可变数组确实提供了极大的便利。它们不仅线程安全，在对它们进行拷贝时也是完全自由的。但这些改变不了它们死板的事实——它们的内容不可被修改。我发现实际内存操作的细节很迷人，这也是我这篇文章聚焦于可变数组的原因">
<meta property="og:type" content="article">
<meta property="og:title" content="NSMutableArray原理揭露">
<meta property="og:url" content="http://blog.joyingx.me/2015/05/03/NSMutableArray 原理揭露/index.html">
<meta property="og:site_name" content="JoyingX's Blog">
<meta property="og:description" content="本文翻译自 Exposing NSMutableArray，译文原地址为NSMutableArray 原理揭露。
以下为译文：
我总好奇 NSMutableArray 内部是如何工作的。别误会，不可变数组确实提供了极大的便利。它们不仅线程安全，在对它们进行拷贝时也是完全自由的。但这些改变不了它们死板的事实——它们的内容不可被修改。我发现实际内存操作的细节很迷人，这也是我这篇文章聚焦于可变数组的原因">
<meta property="og:image" content="http://blog.joyingx.me/images/20150503/1.jpg">
<meta property="og:image" content="http://blog.joyingx.me/images/20150503/2.jpg">
<meta property="og:image" content="http://blog.joyingx.me/images/20150503/3.jpg">
<meta property="og:image" content="http://blog.joyingx.me/images/20150503/4.jpg">
<meta property="og:image" content="http://blog.joyingx.me/images/20150503/5.jpg">
<meta property="og:image" content="http://blog.joyingx.me/images/20150503/6.jpg">
<meta property="og:image" content="http://blog.joyingx.me/images/20150503/7.jpg">
<meta property="og:image" content="http://blog.joyingx.me/images/20150503/8.jpg">
<meta property="og:image" content="http://blog.joyingx.me/images/20150503/9.jpg">
<meta property="og:updated_time" content="2015-06-15T00:27:54.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="NSMutableArray原理揭露">
<meta name="twitter:description" content="本文翻译自 Exposing NSMutableArray，译文原地址为NSMutableArray 原理揭露。
以下为译文：
我总好奇 NSMutableArray 内部是如何工作的。别误会，不可变数组确实提供了极大的便利。它们不仅线程安全，在对它们进行拷贝时也是完全自由的。但这些改变不了它们死板的事实——它们的内容不可被修改。我发现实际内存操作的细节很迷人，这也是我这篇文章聚焦于可变数组的原因">
<meta name="twitter:image" content="http://blog.joyingx.me/images/20150503/1.jpg">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.2.x" />



  <link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" />





<script>
  var CONFIG = {
    search: true,
    searchPath: "/search.xml",
    fancybox: true,
    toc: true,
  }
</script>




  



    <title> NSMutableArray原理揭露 · JoyingX's Blog </title>
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">JoyingX's Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
      <a href="/">
        <li class="mobile-menu-item">
          
          
            Home
          
        </li>
      </a>
    
      <a href="/archives/">
        <li class="mobile-menu-item">
          
          
            Archives
          
        </li>
      </a>
    
  </ul>
</nav>

    <div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">JoyingX's Blog</a>
</div>

<nav class="site-navbar">
  
    <ul id="menu" class="menu">
      
        <li class="menu-item">
          <a class="menu-item-link" href="/">
            
            
              Home
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            
            
              Archives
            
          </a>
        </li>
      
      
        <li class="menu-search">
          <form>
            <i class="iconfont icon-search" id="open-search"></i>
            <input type="text" class="search-input" id="search-input" />
            <i class="iconfont icon-close" id="close-search"></i>
          </form>
        </li>
      
    </ul>
  
</nav>
      </header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content">
            
  
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          NSMutableArray原理揭露
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          May 3, 2015
        </span>
      </div>
    </header>

    
    
  <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">文章目录</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#普通-C-数组的问题"><span class="toc-text">普通 C 数组的问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NSMutableArray"><span class="toc-text">NSMutableArray</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Diving-in"><span class="toc-text">Diving in</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#获取并-dump-类"><span class="toc-text">获取并 dump 类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#反汇编类"><span class="toc-text">反汇编类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#剖析方法"><span class="toc-text">剖析方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#参数传递"><span class="toc-text">参数传递</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分析汇编代码"><span class="toc-text">分析汇编代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#设置"><span class="toc-text">设置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#获取计数"><span class="toc-text">获取计数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#边界检查"><span class="toc-text">边界检查</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#计算内存偏移量"><span class="toc-text">计算内存偏移量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#获取数据"><span class="toc-text">获取数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#函数后记-Function-Epilog"><span class="toc-text">函数后记 (Function Epilog)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#全部放到一起"><span class="toc-text">全部放到一起</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ivars-的意思"><span class="toc-text">ivars 的意思</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-代码"><span class="toc-text">C 代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内存布局"><span class="toc-text">内存布局</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#size-gt-fetchOffset"><span class="toc-text">_size > fetchOffset</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#size-lt-fetchOffset"><span class="toc-text">_size <= fetchOffset</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数据结构"><span class="toc-text">数据结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NSArrayM-特性"><span class="toc-text">__NSArrayM 特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#在运行时检查"><span class="toc-text">在运行时检查</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#打印出代码"><span class="toc-text">打印出代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#结果"><span class="toc-text">结果</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#在两端插入或删除会相当地快"><span class="toc-text">在两端插入或删除会相当地快</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#非整数的增长因子"><span class="toc-text">非整数的增长因子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#一旦增长，不再缩小"><span class="toc-text">一旦增长，不再缩小</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#初始化容量几乎完全不重要"><span class="toc-text">初始化容量几乎完全不重要</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#在删除的时候不会清除指针"><span class="toc-text">在删除的时候不会清除指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最糟糕的情形是在中间进行插入或删除"><span class="toc-text">最糟糕的情形是在中间进行插入或删除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#成为一个好的子类公民"><span class="toc-text">成为一个好的子类公民</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Foundations"><span class="toc-text">Foundations</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CFArray"><span class="toc-text">CFArray</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#最后的话"><span class="toc-text">最后的话</span></a></li></ol>
    </div>
  </div>


    <div class="post-content">
      
        <p>本文翻译自 <a href="http://ciechanowski.me/blog/2014/03/05/exposing-nsmutablearray/" target="_blank" rel="external">Exposing NSMutableArray</a>，译文原地址为<a href="http://www.joyingx.me/2015/05/03/NSMutableArray%20%E5%8E%9F%E7%90%86%E6%8F%AD%E9%9C%B2/" target="_blank" rel="external">NSMutableArray 原理揭露</a>。</p>
<p>以下为译文：</p>
<p>我总好奇 <strong>NSMutableArray</strong> 内部是如何工作的。别误会，不可变数组确实提供了极大的便利。它们不仅线程安全，在对它们进行拷贝时也是完全自由的。但这些改变不了它们死板的事实——它们的内容不可被修改。我发现实际内存操作的细节很迷人，这也是我这篇文章聚焦于可变数组的原因。</p>
<p>当我在说明我是如何研究 <strong>NSMutableArray</strong> 的整个过程时，这篇文章会得相当具有技术性。会有一整个章节讨论 <strong>ARM64 汇编</strong> (the ARM64 assembly)，所以当你感觉到无聊时，不要犹豫，直接跳过那部分内容。一旦我们讨论完那些底层细节，我会展示关于这个类的隐藏特性。</p>
<p><strong>NSmutableArray</strong> 的实现细节之所以私有是有原因的。得益于其底下的子类 (underlying subclasses) 和 ivar 布局 (ivar layouts)，还有算法和数据结构的支撑，它们几乎可以随时改变。无视掉那些注意事项，我们值得去掀开 <strong>NSMutableArray</strong> 的引擎盖窥视一番，搞清楚它是如何工作的和能期望它做什么。接下来的学习基于 iOS 7.0 SDK。</p>
<p>和往常一样，你可以在我的<a href="https://github.com/Ciechan/NSMutableArrayExplorer" target="_blank" rel="external">GitHub</a>上找到接下来的 Xcode 项目。<br><a id="more"></a></p>
<h2 id="普通-C-数组的问题"><a href="#普通-C-数组的问题" class="headerlink" title="普通 C 数组的问题"></a>普通 C 数组的问题</h2><p>任何典型的程序员都知道 C 数组的原理。可以归结为一段能被方便读写的连续内存空间。数组和指针并不相同 (详见 <a href="http://www.amazon.com/Expert-Programming-Peter-van-Linden/dp/0131774298" target="_blank" rel="external">Expert C Programming</a> 或 <a href="http://eli.thegreenplace.net/2009/10/21/are-pointers-and-arrays-equivalent-in-c/" target="_blank" rel="external">这篇文章</a>)，不能说：一块被 <strong>malloc</strong> 过的内存空间等同于一个数组 (一种被滥用了的说法)。</p>
<p>使用一段线性内存空间的一个最明显的缺点是，在下标 0 处插入一个元素时，需要移动其它所有的元素，即 <strong>memmove</strong> 的原理：</p>
<p><a href="/images/20150503/1.jpg"><img src="/images/20150503/1.jpg" alt="C 数组在下标 0 处插入元素"></a> </p>
<p>同样地，假如想要保持相同的内存指针作为首个元素的地址，移除第一个元素需要进行相同的动作：</p>
<p><a href="/images/20150503/2.jpg"><img src="/images/20150503/2.jpg" alt="C 数组移除下标 0 处的元素"></a></p>
<p>当数组非常大时，这样很快会成为问题。显而易见，直接指针存取在数组的世界里必定不是最高级的抽象。C 风格的数组通常很有用，但 Obj-C 程序员每天的主要工作使得它们需要 <strong>NSMutableArray</strong> 这样一个可变的、可索引的容器。</p>
<h2 id="NSMutableArray"><a href="#NSMutableArray" class="headerlink" title="NSMutableArray"></a>NSMutableArray</h2><h3 id="Diving-in"><a href="#Diving-in" class="headerlink" title="Diving in"></a>Diving in</h3><p>尽管苹果公布了很多库的源码，<strong>Foundation</strong> 及其 <strong>NSMutableArray</strong> 却并没有被开源。不过，很多工具使得发掘其奥秘能稍微轻松一点。我们从尽可能高的层级开始，往底层去获取其它不可获取的细节。</p>
<h3 id="获取并-dump-类"><a href="#获取并-dump-类" class="headerlink" title="获取并 dump 类"></a>获取并 dump 类</h3><p><strong>NSMutableArray</strong> 是一个类簇——其具体实现实际上是 <strong>NSMutableArray</strong> 本身的子类。<strong>+[NSMutableArray new]</strong> 实际上返回的是哪个类的实例呢？利用 LLDB 我们连代码都不用写就能知道：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(lldb) po [[<span class="built_in">NSMutableArray</span> new] <span class="keyword">class</span>]  </div><div class="line">__NSArrayM</div></pre></td></tr></table></figure><br>有了类名，我们可以使用<a href="http://stevenygard.com/projects/class-dump/" target="_blank" rel="external">class-dump</a>。这个方便的工具伪造了从提供分析的二进制获得的类的头文件。使用下面的一行命令，我们可以提取出我们感兴趣的 ivar 布局 (ivar layout)：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./<span class="keyword">class</span>-dump --arch arm64 /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS7<span class="number">.0</span>.sdk/System/Library/Frameworks/CoreFoundation.framework/CoreFoundation | pcregrep -M <span class="string">"^[@ws]*__NSArrayM[sw:&#123;;*]*&#125;"</span></div></pre></td></tr></table></figure><br>我用了一个正则表达式，所以上面的命令不能获得全部的信息，但却提供了我们想要的结果：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">__NSArrayM</span> : <span class="title">NSMutableArray</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> _used;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> _doHardRetain:<span class="number">1</span>;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> _doWeakAccess:<span class="number">1</span>;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> _size:<span class="number">62</span>;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> _hasObjects:<span class="number">1</span>;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> _hasStrongReferences:<span class="number">1</span>;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> _offset:<span class="number">62</span>;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> _mutations;</div><div class="line">    <span class="keyword">id</span> *_list;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>原始输出的位字段被指定为 <strong>unsigned int</strong> 类型，但显然无法将 62 字节放入一个 32 字节的整型中—— class-dump 还未能对 ARM64 的库进行正确的解析。尽管有些小缺陷，但通过查看它的 ivars，已经能够了解很多关于该类的信息了。 </p>
<h3 id="反汇编类"><a href="#反汇编类" class="headerlink" title="反汇编类"></a>反汇编类</h3><p>在我的研究中，最重要的工具是 <a href="http://www.hopperapp.com/" target="_blank" rel="external">Hopper</a>。我爱死这个反汇编程序了。它是那些想知道任何事物工作原理、充满求知欲的灵魂必不可少的工具。Hopper 最强大的特性是能生成类 C 语言伪代码，而且足够清晰地去掌握实现的要旨。</p>
<p>用来理解 <strong>__NSArrayM</strong> 最重要的方法是 <strong>- ObjectAtIndex:</strong>。Hopper 很好地给出了 ARMv7 的伪代码，但这些还不能在 ARM64 上好好工作。我想有 ARMv7 提供对应的提示来动手写这伪代码，会是一次很好的练习。</p>
<h3 id="剖析方法"><a href="#剖析方法" class="headerlink" title="剖析方法"></a>剖析方法</h3><p>带着 <a href="https://silver.arm.com/download/ARM_and_AMBA_Architecture/AR100-DA-70501-r0p0-00eac5/ARMv8_ISA_PRD03-GENC-010197-30-0.pdf" target="_blank" rel="external">ARMv8 Instruction Set Overview</a> 和一堆有根据的推测，我想我正确地破译了该汇编代码。然而作为一个智慧的终极来源，你不应该相信接下来的分析。我还是个新手。</p>
<h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><p>作为起点，我们应该注意，每个 Obj-C 方法实际上是一个多了两个参数的 C 函数。第一个参数是 <strong>self</strong>，一个指向成为方法调用接收者的对象的指针。第二个参数是 <strong>_cmd</strong>，用于表示当前的 selector。</p>
<p>可以说，与 <strong>- objectAtIndex:</strong> 等价的 C 风格函数声明如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> objectAtIndex(<span class="built_in">NSArray</span> *<span class="keyword">self</span>, SEL _cmd, <span class="built_in">NSUInteger</span> index);</div></pre></td></tr></table></figure><br>从 ARM64 开始，这些类型的参数就被传递给连续的寄存器，我们可以假设 <strong>self</strong> 指针在 <strong>x0</strong> 寄存器，<strong>_cmd</strong> 在 <strong>x1</strong>寄存器，还有对象的 <strong>index</strong> 在 <strong>x2</strong> 寄存器。对于参数传递的细节请参考 <a href="http://infocenter.arm.com/help/topic/com.arm.doc.ihi0055b/IHI0055B_aapcs64.pdf" target="_blank" rel="external">ARM Procedure Call Standard</a>，需要注意 Apple 的 iOS 版本会有一些<a href="https://developer.apple.com/library/ios/documentation/Xcode/Conceptual/iPhoneOSABIReference/Articles/ARM64FunctionCallingConventions.html" target="_blank" rel="external">分歧</a>。</p>
<h3 id="分析汇编代码"><a href="#分析汇编代码" class="headerlink" title="分析汇编代码"></a>分析汇编代码</h3><p>这看起来有点恐怖。一次性分析一大块汇编代码可不是明智的行为，下面的代码我们会一步步来，理解每一行做了什么。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="number">0xc2d4</span>         stp        x29, x30, [sp, #<span class="number">0xfffffff0</span>]  </div><div class="line"><span class="number">0xc2d8</span>         mov        x29, sp  </div><div class="line"><span class="number">0xc2dc</span>         sub        sp, sp, #<span class="number">0x20</span>  </div><div class="line"><span class="number">0xc2e0</span>         adrp       x8, #<span class="number">0x1d1000</span>  </div><div class="line"><span class="number">0xc2e4</span>         ldrsw      x8, [x8, #<span class="number">0x2c</span>]  </div><div class="line"><span class="number">0xc2e8</span>         ldr        x8, [x0, x8]  </div><div class="line"><span class="number">0xc2ec</span>         cmp        x8, x2  </div><div class="line"><span class="number">0xc2f0</span>         b.ls       <span class="number">0xc33c</span>  </div><div class="line"></div><div class="line"><span class="number">0xc2f4</span>         adrp       x8, #<span class="number">0x1d1000</span>  </div><div class="line"><span class="number">0xc2f8</span>         ldrsw      x8, [x8, #<span class="number">0x30</span>]  </div><div class="line"><span class="number">0xc2fc</span>         ldr        x8, [x0, x8]  </div><div class="line"><span class="number">0xc300</span>         lsr        x8, x8, #<span class="number">0x2</span>  </div><div class="line"><span class="number">0xc304</span>         adrp       x9, #<span class="number">0x1d1000</span>  </div><div class="line"><span class="number">0xc308</span>         ldrsw      x9, [x9, #<span class="number">0x34</span>]  </div><div class="line"><span class="number">0xc30c</span>         ldr        x9, [x0, x9]  </div><div class="line"><span class="number">0xc310</span>         add        x9, x2, x9, lsr #<span class="number">2</span>  </div><div class="line"><span class="number">0xc314</span>         cmp        x8, x9  </div><div class="line"><span class="number">0xc318</span>         csel       x8, xzr, x8, hi  </div><div class="line"><span class="number">0xc31c</span>         sub        x8, x9, x8  </div><div class="line"><span class="number">0xc320</span>         adrp       x9, #<span class="number">0x1d1000</span>  </div><div class="line"><span class="number">0xc324</span>         ldrsw      x9, [x9, #<span class="number">0x38</span>]  </div><div class="line"><span class="number">0xc328</span>         ldr        x9, [x0, x9]  </div><div class="line"><span class="number">0xc32c</span>         ldr        x0, [x9, x8, lsl #<span class="number">3</span>]  </div><div class="line"><span class="number">0xc330</span>         mov        sp, x29  </div><div class="line"><span class="number">0xc334</span>         ldp        x29, x30, [sp], #<span class="number">0x10</span>  </div><div class="line"><span class="number">0xc338</span>         ret  </div></pre></td></tr></table></figure></p>
<h3 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h3><p>我们从一段似乎是 ARM64 的<a href="http://en.wikipedia.org/wiki/Function_prologue" target="_blank" rel="external">函数序言 (function prologue)</a>开始。先把栈中的 <strong>x29</strong> 和 <strong>x30</strong> 寄存器保存起来，然后将当前栈指针移动到 <strong>x29</strong> 寄存器：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">0xc2d4</span>         stp        x29, x30, [sp, #<span class="number">0xfffffff0</span>]!</div><div class="line"><span class="number">0xc2d8</span>         mov        x29, sp</div></pre></td></tr></table></figure><br>在栈上开辟一些空间（减，因为栈向下增长）：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="number">0xc2dc</span>         sub        sp, sp, #<span class="number">0x20</span></div></pre></td></tr></table></figure><br>我们感兴趣的路径代码似乎没有使用这段空间。然而，越界 (out of bounds) 异常抛出代码会调用一些其它函数，因此序言必须为此选项提供便利。</p>
<h3 id="获取计数"><a href="#获取计数" class="headerlink" title="获取计数"></a>获取计数</h3><p>接下来两行代码执行<a href="http://en.wikipedia.org/wiki/Addressing_mode#PC-relative_2" target="_blank" rel="external">程序计数器相对寻址 (program counter relative addressing)</a>。地址编码的具体细节<a href="http://kitoslab.blogspot.com/2012/10/armv8-aarch64-instruction-encoding.html" target="_blank" rel="external">相当复杂</a>且文献稀少。Hopper 自动计算出了合理的偏移量：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">0xc2e0</span>         adrp       x8, #<span class="number">0x1d1000</span></div><div class="line"><span class="number">0xc2e4</span>         ldrsw      x8, [x8, #<span class="number">0x2c</span>]</div></pre></td></tr></table></figure><br>上面的两行代码会获取位于 <strong>0x1d102c</strong> 内存空间的内容，然后存储在 <strong>x8</strong> 寄存器。那上面是什么呢？Hopper 可以帮到我们：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">_OBJC_IVAR_$___NSArrayM._used:</div><div class="line"><span class="number">0x1d102c</span>         dd         <span class="number">0x00000008</span></div></pre></td></tr></table></figure><br>这是 <strong>__NSArrayM</strong> 类里的 <strong>_used</strong> ivar 的偏移量。为什么要那么麻烦去做额外的拉取，而不是简单地将变量 <strong>8</strong> 放到汇编程序中？原因就是<a href="http://en.wikipedia.org/wiki/Fragile_base_class" target="_blank" rel="external">易碎的基类 (fragile base class)</a> 问题。现代 Objectie-C 通过让它自身在运行时可以选择去重写在 <strong>0x1d102c</strong> 的值（和所有该问题的其它 ivar 偏移量）来处理这个问题。如果 <strong>NSObject</strong>、<strong>NSArray</strong> 或 <strong>NSMutableArray</strong> 增加新的 ivar，旧的二进制文件仍然可以工作。</p>
<p><a href="/images/20150503/3.jpg"><img src="/images/20150503/3.jpg" alt="运行时系统能在不破坏兼容性的前提下动态修改 ivar 的偏移量"></a></p>
<p>尽管 CPU 不得不做额外的内存拉取工作，但这却是个完美的解决方案，在 <a href="http://www.sealiesoftware.com/blog/archive/2009/01/27/objc_explain_Non-fragile_ivars.html" target="_blank" rel="external">Hamster Emporium</a> 和 <a href="http://www.cocoawithlove.com/2010/03/dynamic-ivars-solving-fragile-base.html" target="_blank" rel="external">Cocoa with Love</a> 有更详细的解释。</p>
<p>现在我们知道了 <strong>_used</strong> 在类里面的偏移量。因为 Obj-C 对象和结构体没什么两样，我们也有了在 <strong>x0</strong> 处的这个结构体的指针，我们所需要做的便是拉取该值:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="number">0xc2e8</span>         ldr        x8, [x0, x8]</div></pre></td></tr></table></figure><br>上面代码的 C 等价代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> newX8 = *(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> *)((<span class="keyword">char</span> *)(__bridge <span class="keyword">void</span> *)self + x8);</div></pre></td></tr></table></figure><br>我更喜欢汇编版本。快速分析反汇编了的 <strong>__NSArrayM</strong> 的 <strong>- count</strong> 方法，揭示了 <strong>_used</strong> ivar 装载着 <strong>__NSArrayM</strong> 的元素数量，而此时我们拿到了它在 <strong>x8</strong> 寄存器的值。</p>
<h3 id="边界检查"><a href="#边界检查" class="headerlink" title="边界检查"></a>边界检查</h3><p>请求了在 <strong>x2</strong> 的索引值和 <strong>x8</strong> 的计数之后，下面的代码对两者做了比较：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">0xc2ec</span>         cmp        x8, x2</div><div class="line"><span class="number">0xc2f0</span>         b.ls       <span class="number">0xc33c</span></div></pre></td></tr></table></figure><br>当 <strong>x8</strong> 的值小于或等于 <strong>x2</strong> 的值时，会跳到 <strong>0xc33c</strong> 处用于处理异常抛出的代码。这是基本的边界检查。如果测试失败（计数小于或等于索引），会抛出异常。我不打算讨论这部分反汇编，因为它们真的没有介绍任何的新东西。如果通过了测试（计数大于索引），会继续简单地按顺序执行指令。</p>
<h3 id="计算内存偏移量"><a href="#计算内存偏移量" class="headerlink" title="计算内存偏移量"></a>计算内存偏移量</h3><p>我们前面看过这个，这次要拉取位于 <strong>0x1d1030</strong> 的 <strong>_size</strong> ivar 的偏移量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">0xc2f4         adrp       x8, #0x1d1000</div><div class="line">0xc2f8         ldrsw      x8, [x8, #0x30]</div></pre></td></tr></table></figure><br>然后检索它的内容并向右移动两位：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">0xc2fc</span>         ldr        x8, [x0, x8]</div><div class="line"><span class="number">0xc300</span>         lsr        x8, x8, #<span class="number">0x2</span></div></pre></td></tr></table></figure><br>为什么要移动呢？我们看看 dump 出来的头文件：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> _doHardRetain:<span class="number">1</span>;</div><div class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> _doWeakAccess:<span class="number">1</span>;</div><div class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> _size:<span class="number">62</span>;</div></pre></td></tr></table></figure><br>原来是三个位字段分享了同个存储空间，所以要获得 <strong>_size</strong> 的实际值，我们要将值右移，丢弃留给 <strong>_doHardRetain</strong> 和 <strong>_doWeakAccess</strong> 的位。<strong>_doHardRetain</strong> 和 <strong>_doWeakAccess</strong> 的 ivar 偏移量恰好相同，但是它们的位存取代码显然不同。</p>
<p>接下来是同样的操作，我们拿到（位于 <strong>0x1d1034</strong>）<strong>_offset</strong> ivar 的内容，将其放入 <strong>x9</strong> 寄存器：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="number">0xc310</span>         add        x9, x2, x9, lsr #<span class="number">2</span></div></pre></td></tr></table></figure><br>接下来的三行代码是最重要的代码。首先，比较了 <strong>_size</strong>（位于 <strong>x8</strong>）和 <strong>_offset + index</strong>（位于 <strong>x9</strong>）：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="number">0xc314</span>         cmp        x8, x9</div></pre></td></tr></table></figure><br>然后基于上述比较的结果，有条件地选择一个寄存器的值。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="number">0xc318</span>         csel       x8, xzr, x8, hi</div></pre></td></tr></table></figure><br>相当于 C 语言的 ?: 运算符：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">x8 = hi ? xzr : x8;      <span class="comment">// csel       x8, xzr, x8, hi</span></div></pre></td></tr></table></figure><br><strong>xzr</strong> 寄存器是一个含有值 <strong>0</strong> 的零寄存器，<strong>hi</strong> 是 <strong>csel</strong> 指令应该检查的<a href="http://en.wikipedia.org/wiki/Status_register" target="_blank" rel="external">条件码 (condition code)</a> 的名字。在这个用例中，我们检查了比较的结果是否是更大（<strong>x8</strong> 的值是否大于 <strong>x9</strong> 的）。</p>
<p>最后，用 <strong>_offset + index</strong>（位于 <strong>x9</strong>）减去 <strong>x8</strong> 的新值，将结果再次存入 <strong>x8</strong>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="number">0xc31c</span>         sub        x8, x9, x8</div></pre></td></tr></table></figure><br>所以刚刚发生了什么？先看看等价的 C 语言代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> tempIndex = _offset + index;        <span class="comment">// add        x9, x2, x9, lsr #2</span></div><div class="line">BOOL isInRange = _size &amp;gt; tempIndex;     <span class="comment">// cmp        x8, x9</span></div><div class="line"><span class="keyword">int</span> diff = isInRange ? <span class="number">0</span> : _size;       <span class="comment">// csel       x8, xzr, x8, hi</span></div><div class="line"><span class="keyword">int</span> fetchIndex = tempIndex - diff;      <span class="comment">// sub        x8, x9, x8</span></div></pre></td></tr></table></figure><br>在 C 代码中，我们无须右移 <strong>_size</strong> 和 <strong>_offset</strong>，编译器会为位字段的存取自动完成这些任务。</p>
<h3 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h3><p>我们快到达目的地了。先将拉取到的 <strong>_list</strong> ivar (<strong>0x1d1038</strong>) 的内容放到 <strong>x9</strong> 寄存器中：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="number">0xc320</span>         adrp       x9, #<span class="number">0x1d1000</span></div><div class="line"><span class="number">0xc324</span>         ldrsw      x9, [x9, #<span class="number">0x38</span>]</div><div class="line"><span class="number">0xc328</span>         ldr        x9, [x0, x9]</div></pre></td></tr></table></figure><br>这时，<strong>x9</strong> 指向含有数据的内存分段的开始。</p>
<p>最后，将存放在 <strong>x8</strong> 里的拉取到的索引值左移3位，与 <strong>x9</strong> 相加，并将内存里的内容放到 <strong>x0</strong> 的位置。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="number">0xc32c</span>         ldr        x0, [x9, x8, lsl #<span class="number">3</span>]</div></pre></td></tr></table></figure><br>这里有两点很重要。第一，每个数据偏移量都以字节为单位。对一个值左移3位相当于将其乘于8，这个结果就是64位架构下指针的大小（8 个字节）。第二，结果存在 <strong>x0</strong> 的位置，即是存储一个返回 NSUInteger 的函数的返回值的寄存器。</p>
<p>这样我们就快完成了。我们拿到了正确的值并存入数组。</p>
<h3 id="函数后记-Function-Epilog"><a href="#函数后记-Function-Epilog" class="headerlink" title="函数后记 (Function Epilog)"></a>函数后记 (Function Epilog)</h3><p>剩下的是一些样板操作，恢复调用之前的寄存器状态和栈指针：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="number">0xc330</span>         mov        sp, x29</div><div class="line"><span class="number">0xc334</span>         ldp        x29, x30, [sp], #<span class="number">0x10</span></div><div class="line"><span class="number">0xc338</span>         ret</div></pre></td></tr></table></figure></p>
<h2 id="全部放到一起"><a href="#全部放到一起" class="headerlink" title="全部放到一起"></a>全部放到一起</h2><p>我解释了这些代码是干啥的，但问题是为什么要这么做？</p>
<h3 id="ivars-的意思"><a href="#ivars-的意思" class="headerlink" title="ivars 的意思"></a>ivars 的意思</h3><p>我们来概括下每个 ivar 的意思：</p>
<ul>
<li><strong>_used</strong> 是计数的意思</li>
<li><strong>_list</strong> 是缓冲区指针</li>
<li><strong>_size</strong> 是缓冲区的大小</li>
<li><strong>_offset</strong> 是在缓冲区里的数组的第一个元素索引</li>
</ul>
<h3 id="C-代码"><a href="#C-代码" class="headerlink" title="C 代码"></a>C 代码</h3><p>带着 ivars 和分析了的汇编代码，我们现在可以写一个执行了相同操作的 Objective-C 代码：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span>)objectAtIndex:(<span class="built_in">NSUInteger</span>)index</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (_used &amp;lt;= index) &#123;</div><div class="line">        <span class="keyword">goto</span> ThrowException;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="built_in">NSUInteger</span> fetchOffset = _offset + index;</div><div class="line">    <span class="built_in">NSUInteger</span> realOffset = fetchOffset - (_size &amp;gt; fetchOffset ? <span class="number">0</span> : _size);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> _list[realOffset];</div><div class="line"></div><div class="line">ThrowException:</div><div class="line">    <span class="comment">// exception throwing code</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><br>汇编代码肯定要长的多。</p>
<h3 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h3><p>最关键的部分是决定 <strong>realOffset</strong> 应该等于 <strong>fetchOffset</strong>（减去 0）还是 <strong>fetchOffset</strong> 减 <strong>_size</strong>。看着纯代码不一定能画出完美的图画，我们设想一下两个关于如何获取对象的例子。</p>
<h3 id="size-gt-fetchOffset"><a href="#size-gt-fetchOffset" class="headerlink" title="_size &gt; fetchOffset"></a>_size &gt; fetchOffset</h3><p>这个例子中，偏移量相对较小：</p>
<p><a href="/images/20150503/4.jpg"><img src="/images/20150503/4.jpg" alt="一个简单的例子"></a></p>
<p>为了获取 <strong>0</strong> 处的对象，我们计算出 <strong>fetchOffset</strong> 等于 <strong>3 + 0</strong>。因为 <strong>_size</strong> 大于 <strong>fetchOffset</strong>，<strong>realOffset</strong> 也等于 <strong>3</strong>。代码返回 <strong>_list[3]</strong> 的值。而获取 <strong>4</strong> 处的对象时，<strong>fetchOffset</strong> 等于 <strong>3 + 4</strong>，代码返回 <strong>_list[7]</strong>。</p>
<h3 id="size-lt-fetchOffset"><a href="#size-lt-fetchOffset" class="headerlink" title="_size &lt;= fetchOffset"></a>_size &lt;= fetchOffset</h3><p>当偏移量比较大时会怎样？</p>
<p><a href="/images/20150503/5.jpg"><img src="/images/20150503/5.jpg" alt="一个复杂点的例子"></a> </p>
<p>获取 <strong>0</strong> 处的对象，使得 <strong>fetchOffset</strong> 等于 <strong>7 + 0</strong>，调用方法后如期望的返回 <strong>_list[7]</strong>。然而，获取 <strong>4</strong> 处的对象时，<strong>fetchOffset</strong> 等于 <strong>7 + 4 = 11</strong>，要大于 <strong>_size</strong>。获得的 <strong>realOffset</strong> 要从 <strong>fetchOffset</strong> 减去 <strong>_size</strong>，即 <strong>11 - 10 = 1</strong>，方法返回 <strong>list[1]</strong>。</p>
<p>我们基本上是在做取模运算，当穿过缓存区边界时会转回缓冲区的另一端。</p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>正如你会猜测的，<strong>__NSArrayM</strong> 用了<a href="http://en.wikipedia.org/wiki/Circular_buffer" target="_blank" rel="external">环形缓冲区 (circular buffer)</a>。这个数据结构相当简单，只是比常规数组或缓冲区复杂点。环形缓冲区的内容能在到达任意一端时绕向另一端。</p>
<p>环形缓冲区有一些非常酷的属性。尤其是，除非缓冲区满了，否则在任意一端插入或删除均不会要求移动任何内存。我们来分析这个类如何充分利用环形缓冲区来使得自身比 C 数组强大得多。</p>
<h2 id="NSArrayM-特性"><a href="#NSArrayM-特性" class="headerlink" title="__NSArrayM 特性"></a>__NSArrayM 特性</h2><p>对剩下的反汇编了的方法进行逆向工程将会给出 <strong>__NSArrayM</strong> 内部的明确解释，我们可以利用发现的数据点在更高的等级研究该类。</p>
<h3 id="在运行时检查"><a href="#在运行时检查" class="headerlink" title="在运行时检查"></a>在运行时检查</h3><p>为了在运行时检查 <strong>__NSArrayM</strong>，我们不能简单地粘贴 dump 了的头文件。首先，测试程序在没有为 <strong>__NSArrayM</strong> 提供一个至少为空的 <strong>@implementation</strong> 块时不会被链接。加上这个 <strong>@implementation</strong> 块并不是个好主意。当程序编译和已经运行时，我不完全确定运行时会决定使用哪一个类（如果你知道，请告诉我）。为了安全的缘故，我重命名了类名使得某些东西能独立出来—— <strong>BCExploredMutableArray</strong>。</p>
<p>再则，ARC 不会让我们在没有指定它的所属关系前编译 <strong>id *_list</strong>。我们不会将其写入 ivar，所以预先指定 <strong>id</strong> 为 <strong>__unsafe_unretained</strong> 会对内存管理提供最少的干预。无论如何，我选择了声明 ivar 为 <strong>void </strong> _list**，原因稍后便知晓。</p>
<h3 id="打印出代码"><a href="#打印出代码" class="headerlink" title="打印出代码"></a>打印出代码</h3><p>我们可以创建一个 <strong>NSMutableArray</strong> 的类别 (category)，它会打印出 ivars 和包含在数组里面的所有指针列表的内容：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSString</span> *)explored_description</div><div class="line">&#123;</div><div class="line">    assert([<span class="built_in">NSStringFromClass</span>([<span class="keyword">self</span> <span class="keyword">class</span>]) isEqualToString:<span class="string">@"__NSArrayM"</span>]);</div><div class="line"></div><div class="line">    BCExploredMutableArray *array = (BCExploredMutableArray *)<span class="keyword">self</span>;</div><div class="line"></div><div class="line">    <span class="built_in">NSUInteger</span> size = array-&amp;gt;_size;</div><div class="line">    <span class="built_in">NSUInteger</span> offset = array-&amp;gt;_offset;</div><div class="line"></div><div class="line">    <span class="built_in">NSMutableString</span> *description = [<span class="built_in">NSMutableString</span> stringWithString:<span class="string">@"n"</span>];</div><div class="line"></div><div class="line">    [description appendFormat:<span class="string">@"Size: %lun"</span>, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)size];</div><div class="line">    [description appendFormat:<span class="string">@"Count: %llun"</span>, (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>)array-&amp;gt;_used];</div><div class="line">    [description appendFormat:<span class="string">@"Offset: %lun"</span>, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)offset];</div><div class="line">    [description appendFormat:<span class="string">@"Storage: %pn"</span>, array-&amp;gt;_list];</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &amp;lt; size; i++) &#123;</div><div class="line">        [description appendFormat:<span class="string">@"[%d] %pn"</span>, i, array-&amp;gt;_list[i]];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> description;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><h3 id="在两端插入或删除会相当地快"><a href="#在两端插入或删除会相当地快" class="headerlink" title="在两端插入或删除会相当地快"></a>在两端插入或删除会相当地快</h3><p>我么来思考一下一个非常简单的例子：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSMutableArray</span> *array = [<span class="built_in">NSMutableArray</span> array];</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &amp;lt; <span class="number">5</span>; i++) &#123;</div><div class="line">    [array addObject:@(i)];</div><div class="line">&#125;</div><div class="line"></div><div class="line">[array removeObjectAtIndex:<span class="number">0</span>];</div><div class="line">[array removeObjectAtIndex:<span class="number">0</span>];</div><div class="line"></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [array explored_description]);</div></pre></td></tr></table></figure><br>输出显示移除位于 0 处的对象两次后，只是简单地清除了指针并由此而移动了 <strong>_offset</strong> ivar：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Size: <span class="number">6</span></div><div class="line">Count: <span class="number">3</span></div><div class="line">Offset: <span class="number">2</span></div><div class="line">Storage: <span class="number">0x178245ca0</span></div><div class="line">[<span class="number">0</span>] <span class="number">0x0</span></div><div class="line">[<span class="number">1</span>] <span class="number">0x0</span></div><div class="line">[<span class="number">2</span>] <span class="number">0xb000000000000022</span></div><div class="line">[<span class="number">3</span>] <span class="number">0xb000000000000032</span></div><div class="line">[<span class="number">4</span>] <span class="number">0xb000000000000042</span></div><div class="line">[<span class="number">5</span>] <span class="number">0x0</span></div></pre></td></tr></table></figure><br>这是对上面所做的事的图形化说明：</p>
<p><a href="/images/20150503/6.jpg"><img src="/images/20150503/6.jpg" alt="移除下标 0 处的元素两次"></a></p>
<p>添加元素会怎样呢？我们在一个全新的数组下试试：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSMutableArray</span> *array = [<span class="built_in">NSMutableArray</span> array];</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &amp;lt; <span class="number">4</span>; i++) &#123;</div><div class="line">    [array addObject:@(i)];</div><div class="line">&#125;</div><div class="line">[array insertObject:@(<span class="number">15</span>) atIndex:<span class="number">0</span>];</div></pre></td></tr></table></figure><br>在 0 处插入对象用了环形缓冲区魔法来将新插入的对象放置在缓存区的末端：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Size: <span class="number">6</span></div><div class="line">Count: <span class="number">5</span></div><div class="line">Offset: <span class="number">5</span></div><div class="line">Storage: <span class="number">0x17004a560</span></div><div class="line">[<span class="number">0</span>] <span class="number">0xb000000000000002</span></div><div class="line">[<span class="number">1</span>] <span class="number">0xb000000000000012</span></div><div class="line">[<span class="number">2</span>] <span class="number">0xb000000000000022</span></div><div class="line">[<span class="number">3</span>] <span class="number">0xb000000000000032</span></div><div class="line">[<span class="number">4</span>] <span class="number">0x0</span></div><div class="line">[<span class="number">5</span>] <span class="number">0xb0000000000000f2</span></div></pre></td></tr></table></figure><br>如下图描述：</p>
<p><a href="/images/20150503/7.jpg"><img src="/images/20150503/7.jpg" alt="在下标 0 处添加元素"></a></p>
<p>这是个很棒的消息！这意味着 <strong>__NSArrayM</strong> 可以对任意一端进行处理。你可以使用 <strong>__NSArrayM</strong> 作为栈或队列而没有任何性能问题。</p>
<p>从另一侧说明，你可以看到，在 64 位架构之下的 <strong>NSNumber</strong> 如何使用<a href="http://objectivistc.tumblr.com/post/7872364181/tagged-pointers-and-fast-pathed-cfnumber-integers-in" target="_blank" rel="external">参数指针 (tagged pointers)</a> 来作为存储。</p>
<h3 id="非整数的增长因子"><a href="#非整数的增长因子" class="headerlink" title="非整数的增长因子"></a>非整数的增长因子</h3><p>好吧，这里我稍微作了点弊。虽然我也已经做了一些实验性测试，但我想有一个确切的值，并且我已经偷窥了 <strong>insertObject:atIndex:</strong> 的反汇编程序。每当缓冲区满了，它会重新分配1.625倍大小的空间。我很惊讶它居然不等于 2。</p>
<p>更新：Mike Curtiss 给出了一个关于为什么调整因子等于 2 只是次优选择的<a href="https://github.com/facebook/folly/blob/master/folly/docs/FBVector.md#memory-handling" target="_blank" rel="external">非常好的解释</a>。</p>
<h3 id="一旦增长，不再缩小"><a href="#一旦增长，不再缩小" class="headerlink" title="一旦增长，不再缩小"></a>一旦增长，不再缩小</h3><p>这有点令人震惊：<strong>__NSArrayM</strong> 从不减少它的大小。我们运行下面的代码试试：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSMutableArray</span> *array = [<span class="built_in">NSMutableArray</span> array];</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &amp;lt; <span class="number">10000</span>; i++) &#123;</div><div class="line">    [array addObject:[<span class="built_in">NSObject</span> new]];</div><div class="line">&#125;</div><div class="line">[array removeAllObjects];</div></pre></td></tr></table></figure><br>尽管这里的数组是空的，它仍然保持着很大的缓冲区：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Size: <span class="number">14336</span></div></pre></td></tr></table></figure><br>除非你使用 <strong>NSMutableArray</strong> 去加载一些超大量的数据并且清除数组是为了释放空间，否则这不是你要担忧的问题。</p>
<h3 id="初始化容量几乎完全不重要"><a href="#初始化容量几乎完全不重要" class="headerlink" title="初始化容量几乎完全不重要"></a>初始化容量几乎完全不重要</h3><p>我们用设置为2的连续乘方的初始化容量来分配新数组空间：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &amp;lt; <span class="number">16</span>; i++) &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [[[<span class="built_in">NSMutableArray</span> alloc] initWithCapacity:<span class="number">1</span> &amp;lt;&amp;lt; i] explored_description]);</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>真是意想不到：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Size:<span class="number">2</span>     <span class="comment">// requested capacity - 1</span></div><div class="line">Size:<span class="number">2</span>     <span class="comment">// requested capacity - 2</span></div><div class="line">Size:<span class="number">4</span>     <span class="comment">// requested capacity - 4</span></div><div class="line">Size:<span class="number">8</span>     <span class="comment">// requested capacity - 8</span></div><div class="line">Size:<span class="number">16</span>    <span class="comment">// requested capacity - 16</span></div><div class="line">Size:<span class="number">16</span>    <span class="comment">// requested capacity - 32</span></div><div class="line">Size:<span class="number">16</span>    <span class="comment">// requested capacity - 64</span></div><div class="line">Size:<span class="number">16</span>    <span class="comment">// requested capacity - 128</span></div><div class="line">... <span class="comment">// Size:16 all the way down</span></div></pre></td></tr></table></figure></p>
<h3 id="在删除的时候不会清除指针"><a href="#在删除的时候不会清除指针" class="headerlink" title="在删除的时候不会清除指针"></a>在删除的时候不会清除指针</h3><p>这虽然不怎么重要，但我发现它仍然有趣：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSMutableArray</span> *array = [<span class="built_in">NSMutableArray</span> array];</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &amp;lt; <span class="number">6</span>; i++) &#123;</div><div class="line">    [array addObject:@(i)];</div><div class="line">&#125;</div><div class="line">[array removeObjectAtIndex:<span class="number">1</span>];</div><div class="line">[array removeObjectAtIndex:<span class="number">1</span>];</div><div class="line">[array removeObjectAtIndex:<span class="number">1</span>];</div></pre></td></tr></table></figure><br>输出为：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Size: <span class="number">6</span></div><div class="line">Count: <span class="number">3</span></div><div class="line">Offset: <span class="number">3</span></div><div class="line">Storage: <span class="number">0x17805be10</span></div><div class="line">[<span class="number">0</span>] <span class="number">0xb000000000000002</span></div><div class="line">[<span class="number">1</span>] <span class="number">0xb000000000000002</span></div><div class="line">[<span class="number">2</span>] <span class="number">0xb000000000000002</span></div><div class="line">[<span class="number">3</span>] <span class="number">0xb000000000000002</span></div><div class="line">[<span class="number">4</span>] <span class="number">0xb000000000000042</span></div><div class="line">[<span class="number">5</span>] <span class="number">0xb000000000000052</span></div></pre></td></tr></table></figure><br>当往前移动它的对象时，<strong>__NSArrayM</strong> 不会麻烦地去清除前一个空间。无论如何，对象没有被清除。这不是 <strong>NSNumber</strong> 在施展它的魔法，<strong>NSObject</strong> 也表现一致。</p>
<p>这解释了我为什么选择定义 <strong>_list</strong> ivar 为 <strong>void **</strong>。如果 <strong>_list</strong> 声明为 <strong>id *</strong>，那么接下来的循环将会在给 <strong>object</strong> 赋值时崩溃：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &amp;lt; size; i++) &#123;</div><div class="line">    <span class="keyword">id</span> object = array-&amp;gt;_list[i];</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">"%p"</span>, object);</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>ARC 隐式地插入一个 retain/release 对，且控制着释放对象。尽管预先定义 <strong>id object</strong> 为 <strong>__unsafe_unretained</strong> 解决了问题，但我完全不想任何人或东西去调用这串游离指针的任何方法。这就是我使用 <strong>void **</strong> 的原因。</p>
<h3 id="最糟糕的情形是在中间进行插入或删除"><a href="#最糟糕的情形是在中间进行插入或删除" class="headerlink" title="最糟糕的情形是在中间进行插入或删除"></a>最糟糕的情形是在中间进行插入或删除</h3><p>这两个例子中，我们将会粗暴地从一个数组中间移除元素：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSMutableArray</span> *array = [<span class="built_in">NSMutableArray</span> array];</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &amp;lt; <span class="number">6</span>; i++) &#123;</div><div class="line">    [array addObject:@(i)];</div><div class="line">&#125;</div><div class="line">[array removeObjectAtIndex:<span class="number">3</span>];</div></pre></td></tr></table></figure><br>从输出中我们看到顶部的元素往下移动，底部为低索引（注意 <strong>[5]</strong> 处的游离指针）：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[<span class="number">0</span>] <span class="number">0xb000000000000002</span></div><div class="line">[<span class="number">1</span>] <span class="number">0xb000000000000012</span></div><div class="line">[<span class="number">2</span>] <span class="number">0xb000000000000022</span></div><div class="line">[<span class="number">3</span>] <span class="number">0xb000000000000042</span></div><div class="line">[<span class="number">4</span>] <span class="number">0xb000000000000052</span></div><div class="line">[<span class="number">5</span>] <span class="number">0xb000000000000052</span></div></pre></td></tr></table></figure><br><a href="/images/20150503/8.jpg"><img src="/images/20150503/8.jpg" alt="移除下标 3 处的元素"></a></p>
<p>然而，当我们调用 <strong>[array removeObjectAtIndex:2]</strong> 时，底部的元素往上移动，顶部为高索引：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[<span class="number">0</span>] <span class="number">0xb000000000000002</span></div><div class="line">[<span class="number">1</span>] <span class="number">0xb000000000000002</span></div><div class="line">[<span class="number">2</span>] <span class="number">0xb000000000000012</span></div><div class="line">[<span class="number">3</span>] <span class="number">0xb000000000000032</span></div><div class="line">[<span class="number">4</span>] <span class="number">0xb000000000000042</span></div><div class="line">[<span class="number">5</span>] <span class="number">0xb000000000000052</span></div></pre></td></tr></table></figure><br><a href="/images/20150503/9.jpg"><img src="/images/20150503/9.jpg" alt="移除下标 2 处的元素"></a></p>
<p>往中部插入对象有非常相似的结果。合理的解释就是，<strong>__NSArrayM</strong> 试着去最小化内存的移动，因此会移动最少的一边元素。</p>
<h3 id="成为一个好的子类公民"><a href="#成为一个好的子类公民" class="headerlink" title="成为一个好的子类公民"></a>成为一个好的子类公民</h3><p>正如 <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSMutableArray_Class/Reference/Reference.html" target="_blank" rel="external">NSMutableArray Class Reference</a> 的讨论，每个 <strong>NSMutableArray</strong> 子类必须实现下面 7 个方法：</p>
<ul>
<li><strong>- count</strong></li>
<li><strong>- objectAtIndex:</strong></li>
<li><strong>- insertObject:atIndex:</strong></li>
<li><strong>- removeObjectAtIndex:</strong></li>
<li><strong>- addObject:</strong></li>
<li><strong>- removeLastObject</strong></li>
<li><strong>- replaceObjectAtIndex:withObject:</strong></li>
</ul>
<p>毫不意外的是，<strong>__NSArrayM</strong> 履行了这个规定。然而，<strong>__NSArrayM</strong> 的所有实现方法列表相当短且不包含 21 个额外的在 <strong>NSMutableArray</strong> 头文件列出来的方法。谁负责执行这些方法呢？</p>
<p>这证明它们只是 <strong>NSMutableArray</strong> 类自身的一部分。这会相当的方便：任何 <strong>NSMutableArray</strong> 的子类只须实现 7 个最基本的方法。所有其它高等级的抽象建立在它们的基础之上。例如 <strong>- removeAllObjects</strong> 方法简单地往回迭代，一个个地调用 <strong>- removeObjectAtIndex:</strong>。下面是伪代码：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// we actually know this is safe, since count is stored on 62 bits</span></div><div class="line"><span class="comment">// and casting to NSInteger will *not* overflow</span></div><div class="line"><span class="built_in">NSInteger</span> count = (<span class="built_in">NSInteger</span>)[<span class="keyword">self</span> count];</div><div class="line"><span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</div><div class="line">  <span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">count--;</div><div class="line"><span class="keyword">do</span> &#123;</div><div class="line">  [<span class="keyword">self</span> removeObjectAtIndex:count];</div><div class="line">  count--;</div><div class="line">&#125; <span class="keyword">while</span> (count &amp;gt;= <span class="number">0</span>);</div></pre></td></tr></table></figure><br>然而，它是有道理的：<strong>__NSArrayM</strong> 重新实现了它超类的一些方法。例如，尽管<strong>NSArray</strong> 提供了 <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/NSFastEnumeration_protocol/" target="_blank" rel="external">NSFastEnumeration</a> 协议的 <strong>- countByEnumeratingWithState:objects:count:</strong> 方法默认实现，但 <strong>__NSArrayM</strong> 仍然有它自己的代码路径 (code-path)。</p>
<h2 id="Foundations"><a href="#Foundations" class="headerlink" title="Foundations"></a>Foundations</h2><p>我总觉得 Foundation 是 CoreFoundation 的小型封装器 (thin wrapper)。我的论点很简单：当 CF<em> 类可用时，不需要重新发明实现了全新的 NS</em> 类的轮子。当我知道 <strong>NSArray</strong> 或 <strong>NSMutableArray</strong> 和 <strong>CFArray</strong> 完全没有共同点时相当震惊。</p>
<h3 id="CFArray"><a href="#CFArray" class="headerlink" title="CFArray"></a>CFArray</h3><p>关于 CFArray 最好的特点便是：它是<a href="http://opensource.apple.com/source/CF/CF-855.11/CFArray.c" target="_blank" rel="external">开源的</a>。这将会是一个快速的概述，尽管源代码完全公开，饥渴地等着被阅读。<strong>CFArray</strong> 中最重要的函数是 <a href="https://gist.github.com/Ciechan/9258194#file-cfarray-c-L923" target="_blank" rel="external">_CFArrayReplaceValues</a>。它被下面这些函数调用：</p>
<ul>
<li><a href="https://gist.github.com/Ciechan/9258194#file-cfarray-c-L693" target="_blank" rel="external">CFArrayAppendValue</a></li>
<li><a href="https://gist.github.com/Ciechan/9258194#file-cfarray-c-L703" target="_blank" rel="external">CFArraySetValueAtIndex</a></li>
<li><a href="https://gist.github.com/Ciechan/9258194#file-cfarray-c-L729" target="_blank" rel="external">CFArrayInsertValueAtIndex</a></li>
<li><a href="https://gist.github.com/Ciechan/9258194#file-cfarray-c-L760" target="_blank" rel="external">CFArrayRemoveValueAtIndex</a></li>
<li><a href="https://gist.github.com/Ciechan/9258194#file-cfarray-c-L918" target="_blank" rel="external">CFArrayReplaceValues</a>（注意前面没有下划线）</li>
</ul>
<p>基本上，<strong>CFArray</strong> 移动内存空间是围绕这最高效趋势的变化，类似于 <strong>__NSArrayM</strong> 做得工作。然而，<strong>CFArray</strong> 不使用环形缓冲区。反而使用一个两端都填充着零的更大的缓冲区，使得枚举和获取正确的对象变得更加简单。在任意一端添加元素只是简单地吃到剩余的被填充的内存。</p>
<h2 id="最后的话"><a href="#最后的话" class="headerlink" title="最后的话"></a>最后的话</h2><p>尽管 <strong>CFArray</strong> 服务于稍微更通用些的目的，但我发现它吸引人的是，它的内部做着不是和 <strong>__NSArrayM</strong> 一样的事。尽管我以为发现一个共同的地方并且制造一个单一的、典型的实现会有用，但也许有一些其它的因素导致这样的分立。</p>
<p>这两者有什么共同点？它们是像<a href="http://en.wikipedia.org/wiki/Double-ended_queue" target="_blank" rel="external">双向队列</a>这类抽象数据类型的具体实现。不管它的名字，<strong>NSMutableArray</strong> 是一个类固醇数组，剥除了 C 风格数组对应的缺点。</p>
<p>就我个人而言，我很高兴在任意一端插入或删除能有固定时间的性能。我不再对我自己使用 <strong>NSMutableArray</strong> 作为队列而质疑。它做得相当好。</p>

      
    </div>

    
      
      

  <div class="post-copyright">
    <p class="copyright-item">
      <span>作者: </span>
      <span>Joying Xie</span>
    </p>
    <p class="copyright-item">
      <span>来源: </span>
      <a href="http://blog.joyingx.me">http://blog.joyingx.me</a>
    </p>
    <p class="copyright-item">
      <span>链接: </span>
      <a href="http://blog.joyingx.me/2015/05/03/NSMutableArray 原理揭露/">http://blog.joyingx.me/2015/05/03/NSMutableArray 原理揭露/</a>
    </p>

    <p class="copyright-item lincese">
      
      本文采用<a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可
    </p>
  </div>



      
      
  <div class="post-reward">
    <input type="checkbox" name="reward" id="reward" hidden />
    <label class="reward-button" for="reward">赞赏支持</label>
    <div class="qr-code">
      
      
        <label class="qr-code-image" for="reward">
          <img class="image" src="/images/reward/WeChat.JPG" title="wechat">
        </label>
      
      
        <label class="qr-code-image" for="reward">
          <img class="image" src="/images/reward/AliPay.JPG" title="alipay">
        </label>
      
    </div>
  </div>

    

    
  </article>


          </div>
          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>

        </div>  
      </main>

      <footer id="footer" class="footer">

  <div class="social-links">
    
      
        
          <a href="mailto:joyingx@gmail.com" class="iconfont icon-email" title="email"></a>
        
      
    
      
    
      
        
          <a href="https://twitter.com/joyingx" class="iconfont icon-twitter" title="twitter"></a>
        
      
    
      
    
      
    
      
    
      
        
          <a href="https://github.com/joyingx" class="iconfont icon-github" title="github"></a>
        
      
    
      
    
      
    
    
    
  </div>


<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://hexo.io/">Hexo</a> 强力驱动
  </span>
  
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">
    
    &copy; 
     
      2015 - 
    
    2017

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Joying Xie</span>
  </span>
</div>
      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>

    
  
  
  <script type="text/javascript">
    var disqus_config = function () {
        this.page.url = 'http://blog.joyingx.me/2015/05/03/NSMutableArray 原理揭露/';
        this.page.identifier = '2015/05/03/NSMutableArray 原理揭露/';
        this.page.title = 'NSMutableArray原理揭露';
    };
    (function() {
    var d = document, s = d.createElement('script');

    s.src = '//joyingx.disqus.com/embed.js';

    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
    })();  
  </script>




    
  





  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  

  
    <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  


    <script type="text/javascript" src="/js/src/even.js?v=2.2.x"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=2.2.x"></script>

    
  <script type="text/html" id="search-result">
    <article class="post">
      <header class="post-header">
        <h1 class="post-title">
          <a href="$url$" class="post-link">
            $title$
          </a>
        </h1>
      </header>
      <div class="post-content">
        $content$
        <div class="read-more">
          <a href="$url$" class="read-more-link">
            阅读更多
          </a>
        </div>
      </div>
    </article>
  </script>
  <script type="text/html" id="no-search-result">
    <div class="no-result">
      <h2>No result found!</h2>
    </div>
  </script>
  <script type="text/javascript" src="/js/src/search.js?v=2.2.x"></script>

  </body>
</html>